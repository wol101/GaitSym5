diff --git a/CMakeLists.txt b/CMakeLists.txt
index 20551cf..0d2a364 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -70,15 +70,25 @@ add_custom_target(copyShaders ALL SOURCES ${SHADER_FILES})
 # Add dependencies
 add_subdirectory(libs)
 
+if(SDFLIB_USE_ENOKI)
+    target_link_libraries(${PROJECT_NAME} PUBLIC enoki)
+    target_link_libraries(${PROJECT_NAME} PUBLIC fcpw)
+    target_compile_definitions(${PROJECT_NAME} PUBLIC -DENOKI_AVAILABLE)
+endif()
+
+if(SDFLIB_USE_ASSIMP)
+    target_link_libraries(${PROJECT_NAME} PUBLIC assimp)
+    target_compile_definitions(${PROJECT_NAME} PUBLIC -DASSIMP_AVAILABLE)
+endif()
+
+if(SDFLIB_BUILD_APPS OR SDFLIB_BUILD_DEBUG_APPS)
+    target_link_libraries(${PROJECT_NAME} PUBLIC args)
+    target_link_libraries(${PROJECT_NAME} PUBLIC stb_image)
+endif()
+    
 target_link_libraries(${PROJECT_NAME} PUBLIC glm)
-target_link_libraries(${PROJECT_NAME} PUBLIC assimp)
-target_link_libraries(${PROJECT_NAME} PUBLIC args)
 target_link_libraries(${PROJECT_NAME} PUBLIC spdlog)
 target_link_libraries(${PROJECT_NAME} PUBLIC cereal)
-target_link_libraries(${PROJECT_NAME} PUBLIC enoki)
-target_link_libraries(${PROJECT_NAME} PUBLIC eigen)
-target_link_libraries(${PROJECT_NAME} PUBLIC fcpw)
-target_link_libraries(${PROJECT_NAME} PUBLIC stb_image)
 target_link_libraries(${PROJECT_NAME} PUBLIC icg)
 
 if(CMAKE_CXX_COMPILER_ID MATCHES GNU)
@@ -86,17 +96,22 @@ if(CMAKE_CXX_COMPILER_ID MATCHES GNU)
 endif()
 
 # Add openMP
-if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
-    message("Enabling openmp llvm extension")
-    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /openmp:llvm")
-else()
-    find_package(OpenMP)
-    if(NOT OpenMP_CXX_FOUND)
-    	message(FATAL_ERROR  "OpenMP not found")
-    endif()
-    message("OpenMP version ${OpenMP_CXX_VERSION}")
-    target_link_libraries(${PROJECT_NAME} PUBLIC OpenMP::OpenMP_CXX)
-endif()                   
+if(SDFLIB_USE_OPENMP)
+    if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
+        message("Enabling openmp llvm extension")
+        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /openmp:llvm")
+        target_compile_definitions(${PROJECT_NAME} PUBLIC -DOPENMP_AVAILABLE)
+    else()
+        find_package(OpenMP)
+        if(OpenMP_CXX_FOUND)
+        	message("OpenMP version ${OpenMP_CXX_VERSION}")
+            target_link_libraries(${PROJECT_NAME} PUBLIC OpenMP::OpenMP_CXX)
+            target_compile_definitions(${PROJECT_NAME} PUBLIC -DOPENMP_AVAILABLE)
+        else()
+            message("Disabling openmp")
+        endif()
+    endif()    
+endif()
 
 # Add executable
 if (NOT UNIX)
@@ -160,6 +175,7 @@ if(SDFLIB_BUILD_DEBUG_APPS)
     add_executable(GJKtest src/tools/GJKtest/main.cpp)
     target_link_libraries(GJKtest PUBLIC ${PROJECT_NAME})
 
+    target_link_libraries(${PROJECT_NAME} PUBLIC eigen)
     add_executable(CalculateInterpolationParameters src/tools/CalculateInterpolationParameters/main.cpp)
     target_link_libraries(CalculateInterpolationParameters PUBLIC ${PROJECT_NAME})
 
diff --git a/include/SdfLib/ExactOctreeSdf.h b/include/SdfLib/ExactOctreeSdf.h
index 79ad82d..06dd7ac 100644
--- a/include/SdfLib/ExactOctreeSdf.h
+++ b/include/SdfLib/ExactOctreeSdf.h
@@ -214,6 +214,8 @@ private:
 };
 }
 
+#ifdef OPENMP_AVAILABLE
 #include "ExactOctreeSdfDepthFirst.h"
+#endif
 
 #endif
\ No newline at end of file
diff --git a/include/SdfLib/InterpolationMethods.h b/include/SdfLib/InterpolationMethods.h
index 077dfb2..f707d5b 100644
--- a/include/SdfLib/InterpolationMethods.h
+++ b/include/SdfLib/InterpolationMethods.h
@@ -4,7 +4,10 @@
 #include <array>
 
 #include "utils/TriangleUtils.h"
+
+#ifdef ENOKI_AVAILABLE
 #include "enoki/array.h"
+#endif
 
 namespace sdflib
 {
@@ -236,15 +239,6 @@ struct TriLinearInterpolation
 //         outCoeff[63] = 8 * inValues[0][0] + 4 * inValues[0][1] * nodeSize + 4 * inValues[0][2] * nodeSize + 4 * inValues[0][3] * nodeSize + -8 * inValues[1][0] + 4 * inValues[1][1] * nodeSize + -4 * inValues[1][2] * nodeSize + -4 * inValues[1][3] * nodeSize + -8 * inValues[2][0] + -4 * inValues[2][1] * nodeSize + 4 * inValues[2][2] * nodeSize + -4 * inValues[2][3] * nodeSize + 8 * inValues[3][0] + -4 * inValues[3][1] * nodeSize + -4 * inValues[3][2] * nodeSize + 4 * inValues[3][3] * nodeSize + -8 * inValues[4][0] + -4 * inValues[4][1] * nodeSize + -4 * inValues[4][2] * nodeSize + 4 * inValues[4][3] * nodeSize + 8 * inValues[5][0] + -4 * inValues[5][1] * nodeSize + 4 * inValues[5][2] * nodeSize + -4 * inValues[5][3] * nodeSize + 8 * inValues[6][0] + 4 * inValues[6][1] * nodeSize + -4 * inValues[6][2] * nodeSize + -4 * inValues[6][3] * nodeSize + -8 * inValues[7][0] + 4 * inValues[7][1] * nodeSize + 4 * inValues[7][2] * nodeSize + 4 * inValues[7][3] * nodeSize + 0.0f;
 //     }
 
-//     inline static float interpolateValue(const std::array<float, NUM_COEFFICIENTS>& values, glm::vec3 fracPart) 
-//     {
-//         return 0.0f
-//          + values[0] + values[1] * fracPart[0] + values[2] * fracPart[0] * fracPart[0] + values[3] * fracPart[0] * fracPart[0] * fracPart[0] + values[4] * fracPart[1] + values[5] * fracPart[0] * fracPart[1] + values[6] * fracPart[0] * fracPart[0] * fracPart[1] + values[7] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + values[8] * fracPart[1] * fracPart[1] + values[9] * fracPart[0] * fracPart[1] * fracPart[1] + values[10] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + values[11] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + values[12] * fracPart[1] * fracPart[1] * fracPart[1] + values[13] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + values[14] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + values[15] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
-//          + values[16] * fracPart[2] + values[17] * fracPart[0] * fracPart[2] + values[18] * fracPart[0] * fracPart[0] * fracPart[2] + values[19] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + values[20] * fracPart[1] * fracPart[2] + values[21] * fracPart[0] * fracPart[1] * fracPart[2] + values[22] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + values[23] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + values[24] * fracPart[1] * fracPart[1] * fracPart[2] + values[25] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[26] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[27] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[28] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[29] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[30] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[31] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
-//          + values[32] * fracPart[2] * fracPart[2] + values[33] * fracPart[0] * fracPart[2] * fracPart[2] + values[34] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + values[35] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + values[36] * fracPart[1] * fracPart[2] * fracPart[2] + values[37] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[38] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[39] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[40] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[41] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[42] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[43] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[44] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[45] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[46] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[47] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
-//          + values[48] * fracPart[2] * fracPart[2] * fracPart[2] + values[49] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[50] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[51] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[52] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[53] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[54] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[55] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[56] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[57] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[58] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[59] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[60] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[61] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[62] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[63] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2];
-//     }
-
 //     inline static void interpolateVertexValues(const std::array<float, NUM_COEFFICIENTS>& values, glm::vec3 fracPart, float nodeSize, std::array<float, VALUES_PER_VERTEX>& outValues)
 //     {
 //         outValues[0] = 0.0f
@@ -383,6 +377,7 @@ struct TriCubicInterpolation
         outCoeff[63] = 8 * inValues[0][0] + 4 * inValues[0][1] + 4 * inValues[0][2] + 4 * inValues[0][3] + 2 * inValues[0][4] + 2 * inValues[0][5] + 2 * inValues[0][6] + 1 * inValues[0][7] + -8 * inValues[1][0] + 4 * inValues[1][1] + -4 * inValues[1][2] + -4 * inValues[1][3] + 2 * inValues[1][4] + 2 * inValues[1][5] + -2 * inValues[1][6] + 1 * inValues[1][7] + -8 * inValues[2][0] + -4 * inValues[2][1] + 4 * inValues[2][2] + -4 * inValues[2][3] + 2 * inValues[2][4] + -2 * inValues[2][5] + 2 * inValues[2][6] + 1 * inValues[2][7] + 8 * inValues[3][0] + -4 * inValues[3][1] + -4 * inValues[3][2] + 4 * inValues[3][3] + 2 * inValues[3][4] + -2 * inValues[3][5] + -2 * inValues[3][6] + 1 * inValues[3][7] + -8 * inValues[4][0] + -4 * inValues[4][1] + -4 * inValues[4][2] + 4 * inValues[4][3] + -2 * inValues[4][4] + 2 * inValues[4][5] + 2 * inValues[4][6] + 1 * inValues[4][7] + 8 * inValues[5][0] + -4 * inValues[5][1] + 4 * inValues[5][2] + -4 * inValues[5][3] + -2 * inValues[5][4] + 2 * inValues[5][5] + -2 * inValues[5][6] + 1 * inValues[5][7] + 8 * inValues[6][0] + 4 * inValues[6][1] + -4 * inValues[6][2] + -4 * inValues[6][3] + -2 * inValues[6][4] + -2 * inValues[6][5] + 2 * inValues[6][6] + 1 * inValues[6][7] + -8 * inValues[7][0] + 4 * inValues[7][1] + 4 * inValues[7][2] + 4 * inValues[7][3] + -2 * inValues[7][4] + -2 * inValues[7][5] + -2 * inValues[7][6] + 1 * inValues[7][7];
     }
 
+#ifdef ENOKI_AVAILABLE
     using vec4 = enoki::Array<float, 4>;
 
     inline static float interpolateValue(const std::array<float, NUM_COEFFICIENTS>& values, glm::vec3 fracPart) 
@@ -433,6 +428,16 @@ struct TriCubicInterpolation
 
         return sum;
     }
+#else
+    inline static float interpolateValue(const std::array<float, NUM_COEFFICIENTS>& values, glm::vec3 fracPart) 
+    {
+        return 0.0f
+         + values[0] + values[1] * fracPart[0] + values[2] * fracPart[0] * fracPart[0] + values[3] * fracPart[0] * fracPart[0] * fracPart[0] + values[4] * fracPart[1] + values[5] * fracPart[0] * fracPart[1] + values[6] * fracPart[0] * fracPart[0] * fracPart[1] + values[7] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + values[8] * fracPart[1] * fracPart[1] + values[9] * fracPart[0] * fracPart[1] * fracPart[1] + values[10] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + values[11] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + values[12] * fracPart[1] * fracPart[1] * fracPart[1] + values[13] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + values[14] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + values[15] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
+         + values[16] * fracPart[2] + values[17] * fracPart[0] * fracPart[2] + values[18] * fracPart[0] * fracPart[0] * fracPart[2] + values[19] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + values[20] * fracPart[1] * fracPart[2] + values[21] * fracPart[0] * fracPart[1] * fracPart[2] + values[22] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + values[23] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + values[24] * fracPart[1] * fracPart[1] * fracPart[2] + values[25] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[26] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[27] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + values[28] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[29] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[30] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + values[31] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
+         + values[32] * fracPart[2] * fracPart[2] + values[33] * fracPart[0] * fracPart[2] * fracPart[2] + values[34] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + values[35] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + values[36] * fracPart[1] * fracPart[2] * fracPart[2] + values[37] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[38] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[39] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + values[40] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[41] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[42] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[43] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[44] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[45] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[46] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + values[47] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
+         + values[48] * fracPart[2] * fracPart[2] * fracPart[2] + values[49] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[50] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[51] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + values[52] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[53] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[54] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[55] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[56] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[57] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[58] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[59] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[60] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[61] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[62] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + values[63] * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2];
+    }
+#endif
 
     inline static glm::vec3 interpolateGradient(const std::array<float, NUM_COEFFICIENTS>& values, glm::vec3 fracPart) 
     {
@@ -493,4 +498,4 @@ struct TriCubicInterpolation
 };
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/SdfLib/TrianglesInfluence.h b/include/SdfLib/TrianglesInfluence.h
index 3f3d33f..fc2ca52 100644
--- a/include/SdfLib/TrianglesInfluence.h
+++ b/include/SdfLib/TrianglesInfluence.h
@@ -1,7 +1,10 @@
 #ifndef TRIANGLES_INFLUENCE_H
 #define TRIANGLES_INFLUENCE_H
 
+#ifdef ENOKI_AVAILABLE
 #include <fcpw/fcpw.h>
+#endif
+
 #include "utils/Mesh.h"
 #include "utils/TriangleUtils.h"
 #include "OctreeSdfUtils.h"
@@ -1008,6 +1011,7 @@ struct VHQueries
     }
 };
 
+#ifdef ENOKI_AVAILABLE
 template<typename T>
 struct FCPWQueries
 {
@@ -1118,6 +1122,8 @@ struct FCPWQueries
     {
     }
 };
+#endif
+
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/SdfLib/utils/Mesh.h b/include/SdfLib/utils/Mesh.h
index 28d5486..7d21e44 100644
--- a/include/SdfLib/utils/Mesh.h
+++ b/include/SdfLib/utils/Mesh.h
@@ -4,9 +4,11 @@
 #include <string>
 #include <vector>
 #include <glm/glm.hpp>
+#ifdef ASSIMP_AVAILABLE
 #include <assimp/Importer.hpp>
 #include <assimp/scene.h>      
 #include <assimp/postprocess.h>
+#endif
 #include "SdfLib/utils/UsefullSerializations.h"
 
 namespace sdflib
@@ -43,6 +45,23 @@ struct BoundingBox
         return glm::length(glm::max(q,glm::vec3(0.0f))) + glm::min(glm::max(q.x, glm::max(q.y,q.z)),0.0f);
     }
 
+    float getDistance(glm::vec3 point, glm::vec3& outGradient) const
+    {
+        glm::vec3 a = glm::abs(point) - getSize();
+        int k = a[0] > a[1] ? 0 : 1;
+        int l = a[2] > a[k] ? 2 : k;
+        if (a[l] < 0) {
+            outGradient[l] = point[l] / glm::abs(point[l]);
+        } else {
+            glm::vec3 b = glm::max(a, glm::vec3(0.0f));
+            float c = glm::length(b);
+            outGradient[0] = a[0] > 0 ? b[0] / c * point[0] / glm::abs(point[0]) : 0;
+            outGradient[1] = a[1] > 0 ? b[1] / c * point[1] / glm::abs(point[1]) : 0;
+            outGradient[2] = a[2] > 0 ? b[2] / c * point[2] / glm::abs(point[2]) : 0;
+        }
+        return getDistance(point);
+    }
+
     template<class Archive>
     void serialize(Archive & archive)
     {
@@ -54,8 +73,10 @@ class Mesh
 {
 public:
     Mesh() {}
+#ifdef ASSIMP_AVAILABLE
     Mesh(std::string filePath);
     Mesh(const aiMesh* mesh);
+#endif
     Mesh(glm::vec3* vertices, uint32_t numVertices,
          uint32_t* indices, uint32_t numIndices);
 
@@ -74,7 +95,9 @@ public:
     void computeNormals();
     void applyTransform(glm::mat4 trans);
 private:
+#ifdef ASSIMP_AVAILABLE
     void initMesh(const aiMesh* mesh);
+#endif
 
     std::vector<glm::vec3> mVertices;
     std::vector<uint32_t> mIndices;
@@ -83,4 +106,4 @@ private:
 };
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/SdfLib/utils/TriangleUtils.h b/include/SdfLib/utils/TriangleUtils.h
index 9f930ed..6ee2304 100644
--- a/include/SdfLib/utils/TriangleUtils.h
+++ b/include/SdfLib/utils/TriangleUtils.h
@@ -2,6 +2,7 @@
 #define TRIANGLE_UTILS_H
 
 #include <glm/glm.hpp>
+#include <algorithm>
 #include <vector>
 #include <array>
 #include <map>
@@ -401,4 +402,4 @@ namespace TriangleUtils
 }
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/libs/CMakeLists.txt b/libs/CMakeLists.txt
index b48bf39..ea22b9a 100644
--- a/libs/CMakeLists.txt
+++ b/libs/CMakeLists.txt
@@ -14,37 +14,41 @@ if(NOT glm_lib_POPULATED)
 endif()
 
 # assimp
-FetchContent_Declare(assimp_lib
-  GIT_REPOSITORY https://github.com/assimp/assimp.git
-  GIT_TAG 9519a62dd20799c5493c638d1ef5a6f484e5faf1 # 5.2.5
-)
-
-if(NOT assimp_lib)
-	FetchContent_Populate(assimp_lib)
-	
-	set(CMAKE_POLICY_DEFAULT_CMP0077 NEW)
-	set(BUILD_SHARED_LIBS OFF)
-	set(ASSIMP_BUILD_ASSIMP_TOOLS OFF)
-	set(ASSIMP_BUILD_TESTS OFF)
-	set(ASSIMP_INSTALL OFF)
-	set(ASSIMP_INJECT_DEBUG_POSTFIX OFF)
-	set(ASSIMP_BUILD_ASSIMP_VIEW OFF)
+if(SDF_USE_ASSIMP)
+	FetchContent_Declare(assimp_lib
+	  GIT_REPOSITORY https://github.com/assimp/assimp.git
+	  GIT_TAG 9519a62dd20799c5493c638d1ef5a6f484e5faf1 # 5.2.5
+	)
 	
-	add_subdirectory(${assimp_lib_SOURCE_DIR} ${assimp_lib_BINARY_DIR})
+	if(NOT assimp_lib)
+		FetchContent_Populate(assimp_lib)
+		
+		set(CMAKE_POLICY_DEFAULT_CMP0077 NEW)
+		set(BUILD_SHARED_LIBS OFF)
+		set(ASSIMP_BUILD_ASSIMP_TOOLS OFF)
+		set(ASSIMP_BUILD_TESTS OFF)
+		set(ASSIMP_INSTALL OFF)
+		set(ASSIMP_INJECT_DEBUG_POSTFIX OFF)
+		set(ASSIMP_BUILD_ASSIMP_VIEW OFF)
+		
+		add_subdirectory(${assimp_lib_SOURCE_DIR} ${assimp_lib_BINARY_DIR})
+	endif()
 endif()
 
 # args
-FetchContent_Declare(args_lib
-  GIT_REPOSITORY https://github.com/Taywee/args.git
-  GIT_TAG a48e1f880813b367d2354963a58dedbf2b708584 # 6.3.0
-)
-
-FetchContent_GetProperties(args_lib)
-if(NOT args_lib_POPULATED)
-	FetchContent_Populate(args_lib)
-	add_library(args INTERFACE)
-	target_include_directories(args INTERFACE ${args_lib_SOURCE_DIR})
-endif()
+if(SDFLIB_BUILD_APPS OR SDFLIB_BUILD_DEBUG_APPS)
+	FetchContent_Declare(args_lib
+	  GIT_REPOSITORY https://github.com/Taywee/args.git
+	  GIT_TAG a48e1f880813b367d2354963a58dedbf2b708584 # 6.3.0
+	)
+	
+	FetchContent_GetProperties(args_lib)
+	if(NOT args_lib_POPULATED)
+		FetchContent_Populate(args_lib)
+		add_library(args INTERFACE)
+		target_include_directories(args INTERFACE ${args_lib_SOURCE_DIR})
+	endif()
+ endif()
 
 # spdlog
 FetchContent_Declare(spdlog_lib
@@ -76,47 +80,53 @@ if(NOT cereal_lib_POPULATED)
 endif()
 
 # Enoki
-FetchContent_Declare(enoki_lib
-	GIT_REPOSITORY https://github.com/mitsuba-renderer/enoki.git
-	GIT_TAG 2a18afa
-)
-FetchContent_GetProperties(enoki_lib)
-if(NOT enoki_lib_POPULATED)
-	FetchContent_Populate(enoki_lib)
-	add_library(enoki INTERFACE)
-	add_subdirectory(${enoki_lib_SOURCE_DIR} ${enoki_lib_BINARY_DIR})
-	target_include_directories(enoki INTERFACE ${enoki_lib_SOURCE_DIR}/include)
-endif()
-
-# eigen
-FetchContent_Declare(eigen_lib
-GIT_REPOSITORY https://gitlab.com/libeigen/eigen.git
-GIT_TAG 46126273552afe13692929523d34006f54c19719 # 3.4
-)
+if(SDFLIB_USE_ENOKI)
+	FetchContent_Declare(enoki_lib
+		GIT_REPOSITORY https://github.com/mitsuba-renderer/enoki.git
+		GIT_TAG 2a18afa
+	)
+	FetchContent_GetProperties(enoki_lib)
+	if(NOT enoki_lib_POPULATED)
+		FetchContent_Populate(enoki_lib)
+		add_library(enoki INTERFACE)
+		add_subdirectory(${enoki_lib_SOURCE_DIR} ${enoki_lib_BINARY_DIR})
+		target_include_directories(enoki INTERFACE ${enoki_lib_SOURCE_DIR}/include)
+	endif()
 
-FetchContent_GetProperties(eigen_lib)
-if(NOT eigen_lib_POPULATED)
-	FetchContent_Populate(eigen_lib)
-	add_library(eigen INTERFACE)
-	target_include_directories(eigen INTERFACE ${eigen_lib_SOURCE_DIR})
+ 	# FCPW
+	FetchContent_Declare(fcpw_lib
+		GIT_REPOSITORY https://github.com/rohan-sawhney/fcpw.git
+		GIT_TAG dd65ec2
+	)
+	
+	FetchContent_GetProperties(fcpw_lib)
+	if(NOT fcpw_lib_POPULATED)
+		FetchContent_Populate(fcpw_lib)
+		add_subdirectory(${fcpw_lib_SOURCE_DIR} ${fcpw_lib_BINARY_DIR})
+		target_include_directories(fcpw INTERFACE ${fcpw_lib_SOURCE_DIR})
+	endif()
 endif()
 
-# FCPW
-FetchContent_Declare(fcpw_lib
-	GIT_REPOSITORY https://github.com/rohan-sawhney/fcpw.git
-	GIT_TAG dd65ec2
-)
-
-FetchContent_GetProperties(fcpw_lib)
-if(NOT fcpw_lib_POPULATED)
-	FetchContent_Populate(fcpw_lib)
-	add_subdirectory(${fcpw_lib_SOURCE_DIR} ${fcpw_lib_BINARY_DIR})
-	target_include_directories(fcpw INTERFACE ${fcpw_lib_SOURCE_DIR})
-endif()
+# eigen
+if(SDFLIB_BUILD_DEBUG_APPS)
+	FetchContent_Declare(eigen_lib
+	GIT_REPOSITORY https://gitlab.com/libeigen/eigen.git
+	GIT_TAG 46126273552afe13692929523d34006f54c19719 # 3.4
+	)
+	
+	FetchContent_GetProperties(eigen_lib)
+	if(NOT eigen_lib_POPULATED)
+		FetchContent_Populate(eigen_lib)
+		add_library(eigen INTERFACE)
+		target_include_directories(eigen INTERFACE ${eigen_lib_SOURCE_DIR})
+	endif()
+ endif()
 
 # stb
-add_library(stb_image INTERFACE)
-target_include_directories(stb_image INTERFACE stb)
+if(SDFLIB_BUILD_APPS OR SDFLIB_BUILD_DEBUG_APPS)
+	add_library(stb_image INTERFACE)
+	target_include_directories(stb_image INTERFACE stb)
+ endif()
 
 # icg
 add_library(icg INTERFACE)
diff --git a/src/sdf/OctreeSdf.cpp b/src/sdf/OctreeSdf.cpp
index ef8ed4d..0e1eb97 100644
--- a/src/sdf/OctreeSdf.cpp
+++ b/src/sdf/OctreeSdf.cpp
@@ -6,7 +6,9 @@
 #include "SdfLib/InterpolationMethods.h"
 #include "sdf/OctreeSdfDepthFirst.h"
 #include "sdf/OctreeSdfBreadthFirst.h"
+#ifdef OPENMP_AVAILABLE
 #include "sdf/OctreeSdfBreadthFirstNoDelay.h"
+#endif
 #include <array>
 #include <stack>
 
@@ -46,8 +48,11 @@ OctreeSdf::OctreeSdf(const Mesh& mesh, BoundingBox box,
             break;
         case OctreeSdf::InitAlgorithm::CONTINUITY:
             //initOctreeWithContinuity<PerNodeRegionTrianglesInfluence<InterpolationMethod>>(mesh, startDepth, depth, terminationThreshold, terminationRule);
-            // initOctreeWithContinuity<VHQueries<InterpolationMethod>>(mesh, startDepth, depth, terminationThreshold, terminationRule);
+#ifdef OPENMP_AVAILABLE
             initOctreeWithContinuityNoDelay<VHQueries<InterpolationMethod>>(mesh, startDepth, depth, terminationThreshold, terminationRule, numThreads);
+#else
+            initOctreeWithContinuity<VHQueries<InterpolationMethod>>(mesh, startDepth, depth, terminationThreshold, terminationRule);
+#endif            
             break;
         // case OctreeSdf::InitAlgorithm::GPU_IMPLEMENTATION:
         //     Timer time;
@@ -78,7 +83,7 @@ float OctreeSdf::getDistance(glm::vec3 sample) const
        startArrayPos.y < 0 || startArrayPos.y >= mStartGridSize ||
        startArrayPos.z < 0 || startArrayPos.z >= mStartGridSize)
     {
-        return mBox.getDistance(sample) + glm::sqrt(3.0f) * mBox.getSize().x;
+        return mBox.getDistance(sample) + mMinBorderValue;
     }
 
     const OctreeNode* currentNode = &mOctreeData[startArrayPos.z * mStartGridXY + startArrayPos.y * mStartGridSize + startArrayPos.x];
@@ -108,7 +113,7 @@ float OctreeSdf::getDistance(glm::vec3 sample, glm::vec3& outGradient) const
        startArrayPos.y < 0 || startArrayPos.y >= mStartGridSize ||
        startArrayPos.z < 0 || startArrayPos.z >= mStartGridSize)
     {
-        return mBox.getDistance(sample) + mMinBorderValue;
+        return mBox.getDistance(sample, outGradient) + mMinBorderValue;
     }
 
     const OctreeNode* currentNode = &mOctreeData[startArrayPos.z * mStartGridXY + startArrayPos.y * mStartGridSize + startArrayPos.x];
@@ -253,4 +258,4 @@ void OctreeSdf::getDepthDensity(std::vector<float>& depthsDensity)
         size *= 0.125f;
     }
 }
-}
\ No newline at end of file
+}
diff --git a/src/sdf/OctreeSdfDepthFirst.h b/src/sdf/OctreeSdfDepthFirst.h
index 53ee4b2..196d191 100644
--- a/src/sdf/OctreeSdfDepthFirst.h
+++ b/src/sdf/OctreeSdfDepthFirst.h
@@ -7,7 +7,10 @@
 #include "SdfLib/OctreeSdfUtils.h"
 #include <array>
 #include <stack>
+#ifdef OPENMP_AVAILABLE
 #include <omp.h>
+#endif    
+
 
 namespace sdflib
 {
@@ -381,7 +384,9 @@ void OctreeSdf::initOctree(const Mesh& mesh, uint32_t startDepth, uint32_t maxDe
     };
 
     const uint32_t voxlesPerAxis = 1 << startDepth;
+#ifdef OPENMP_AVAILABLE
     if(numThreads < 2)
+#endif
     {
         // Create the grid
         mOctreeData.resize(voxlesPerAxis * voxlesPerAxis * voxlesPerAxis);
@@ -402,7 +407,8 @@ void OctreeSdf::initOctree(const Mesh& mesh, uint32_t startDepth, uint32_t maxDe
 
         mValueRange = mainThread.valueRange;
     }
-    else
+#ifdef OPENMP_AVAILABLE
+    else 
     {
         std::vector<ThreadContext> threadsContext(numThreads, mainThread);
 
@@ -511,6 +517,7 @@ void OctreeSdf::initOctree(const Mesh& mesh, uint32_t startDepth, uint32_t maxDe
             }
         #endif
     }
+#endif
 	
 #ifdef SDFLIB_PRINT_STATISTICS
     SPDLOG_INFO("Used an octree of max depth {}", maxDepth);
@@ -544,4 +551,4 @@ void OctreeSdf::initOctree(const Mesh& mesh, uint32_t startDepth, uint32_t maxDe
 }
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/utils/Mesh.cpp b/src/utils/Mesh.cpp
index b407d38..6fff5fe 100644
--- a/src/utils/Mesh.cpp
+++ b/src/utils/Mesh.cpp
@@ -5,6 +5,7 @@
 
 namespace sdflib
 {
+#ifdef ASSIMP_AVAILABLE
 Mesh::Mesh(std::string filePath)
 {
     Assimp::Importer import;
@@ -28,6 +29,7 @@ Mesh::Mesh(const aiMesh* mesh)
 {
     initMesh(mesh);
 }
+#endif
 
 Mesh::Mesh(glm::vec3* vertices, uint32_t numVertices,
          uint32_t* indices, uint32_t numIndices)
@@ -39,7 +41,7 @@ Mesh::Mesh(glm::vec3* vertices, uint32_t numVertices,
     std::memcpy(mIndices.data(), indices, sizeof(uint32_t) * numIndices);
 }
 
-
+#ifdef ASSIMP_AVAILABLE
 void Mesh::initMesh(const aiMesh* mesh)
 {
     if(!(mesh->mPrimitiveTypes & aiPrimitiveType_TRIANGLE))
@@ -83,6 +85,7 @@ void Mesh::initMesh(const aiMesh* mesh)
 		computeNormals();
 	}
 }
+#endif
 
 void Mesh::computeBoundingBox()
 {
@@ -134,4 +137,4 @@ void Mesh::applyTransform(glm::mat4 trans)
 
     computeBoundingBox();
 }
-}
\ No newline at end of file
+}
